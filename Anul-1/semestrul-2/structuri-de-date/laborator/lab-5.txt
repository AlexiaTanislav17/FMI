#include <iostream>
#include <vector>

using namespace std;

struct TreeNode {
    int data;
    TreeNode* left;
    TreeNode* right;

    TreeNode(int val) : data(val), left(nullptr), right(nullptr) {}
};

TreeNode* buildBalancedBST(const vector<int>& sortedArray, int start, int end) {
    if (start > end) {
        return nullptr;
    }

    int mid = (start + end) / 2;
    TreeNode* root = new TreeNode(sortedArray[mid]);

    root->left = buildBalancedBST(sortedArray, start, mid - 1);
    root->right = buildBalancedBST(sortedArray, mid + 1, end);

    return root;
}

void printInOrder(TreeNode* root) {
    if (root == nullptr) {
        return;
    }

    printInOrder(root->left);
    cout << root->data << " ";
    printInOrder(root->right);
}

int main() {
    vector<int> sortedArray = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

    TreeNode* root = buildBalancedBST(sortedArray, 0, sortedArray.size() - 1);

    cout << "BST: ";
    printInOrder(root);
    cout << endl;

    return 0;
}


----------------------------------alta  varianta----------------------------------------------------------

#include <bits/stdc++.h>
#include <iostream>
#include <vector>
using namespace std;
 
/* A binary tree node has data, pointer to left child
and a pointer to right child */
class node {
public:
    int data;
    node* left;
    node* right;
};
 
// A utility function to create a node
node* newNode(int data)
{
    node* temp = new node();
 
    temp->data = data;
    temp->left = temp->right = NULL;
 
    return temp;
}
 
// A recursive function to construct Full from pre[].
// preIndex is used to keep track of index in pre[].
node* constructTreeUtil(int pre[], int* preIndex, int low,
                        int high, int size)
{
    // Base case
    if (*preIndex >= size || low > high)
        return NULL;
 
    // The first node in preorder traversal is root. So take
    // the node at preIndex from pre[] and make it root, and
    // increment preIndex
    node* root = newNode(pre[*preIndex]);
    *preIndex = *preIndex + 1;
 
    // If the current subarray has only one element, no need
    // to recur
    if (low == high)
        return root;
 
    // Search for the first element greater than root
    int i;
    for (i = low; i <= high; ++i)
        if (pre[i] > root->data)
            break;
 
    // Use the index of element found in preorder to divide
    // preorder array in two parts. Left subtree and right
    // subtree
    root->left = constructTreeUtil(pre, preIndex, *preIndex,
                                   i - 1, size);
    root->right
        = constructTreeUtil(pre, preIndex, i, high, size);
 
    return root;
}
 
// The main function to construct BST from given preorder
// traversal. This function mainly uses constructTreeUtil()
node* constructTree(int pre[], int size)
{
    int preIndex = 0;
    return constructTreeUtil(pre, &preIndex, 0, size - 1,
                             size);
}
 
// A utility function to print inorder traversal of a Binary
// Tree
void printInorder(node* node)
{
    if (node == NULL)
        return;
    printInorder(node->left);
    cout << node->data << " ";
    printInorder(node->right);
}
 
// Driver code
int main()
{
    int pre[] = { 10, 5, 1, 7, 40, 50 };
    int size = sizeof(pre) / sizeof(pre[0]);
 
      // Function call
    node* root = constructTree(pre, size);
 
    printInorder(root);
 
    return 0;
}



------------------------------------------------------------------------------------------------------


TreeNode* mergeTwoBSTs(TreeNode* root1, TreeNode* root2) {
    std::vector<int> inorder1, inorder2;
    inorderTraversal(root1, inorder1);
    inorderTraversal(root2, inorder2);
    
    std::vector<int> mergedInorder = mergeSortedArrays(inorder1, inorder2);
    
    return sortedArrayToBST(mergedInorder, 0, mergedInorder.size() - 1);
}

// Functie pentru a afisa un BST (inordine)
void printInOrder(TreeNode* root) {
    if (root == nullptr) return;
    printInOrder(root->left);
    std::cout << root->val << " ";
    printInOrder(root->right);
}



--------------------------------alta varianta-----------------------------------------------

#include<bits/stdc++.h>
using namespace std;

/* A binary tree node has data, pointer to left child 
and a pointer to right child */
class node 
{ 
	public:
	int data; 
	node* left; 
	node* right; 
}; 

// A utility function to merge two sorted arrays into one 
int *merge(int arr1[], int arr2[], int m, int n); 

// A helper function that stores inorder
// traversal of a tree in inorder array 
void storeInorder(node* node, int inorder[],
							int *index_ptr); 

/* A function that constructs Balanced
Binary Search Tree from a sorted array 
See https://www.geeksforgeeks.org/sorted-array-to-balanced-bst/ */
node* sortedArrayToBST(int arr[], int start, int end); 

/* This function merges two balanced 
BSTs with roots as root1 and root2. 
m and n are the sizes of the trees respectively */
node* mergeTrees(node *root1, node *root2, int m, int n) 
{ 
	// Store inorder traversal of 
	// first tree in an array arr1[] 
	int *arr1 = new int[m]; 
	int i = 0; 
	storeInorder(root1, arr1, &i); 

	// Store inorder traversal of second
	// tree in another array arr2[] 
	int *arr2 = new int[n]; 
	int j = 0; 
	storeInorder(root2, arr2, &j); 

	// Merge the two sorted array into one 
	int *mergedArr = merge(arr1, arr2, m, n); 

	// Construct a tree from the merged 
	// array and return root of the tree 
	return sortedArrayToBST (mergedArr, 0, m + n - 1); 
} 

/* Helper function that allocates
a new node with the given data and 
NULL left and right pointers. */
node* newNode(int data) 
{ 
	node* Node = new node();
	Node->data = data; 
	Node->left = NULL; 
	Node->right = NULL; 

	return(Node); 
} 

// A utility function to print inorder
// traversal of a given binary tree 
void printInorder(node* node) 
{ 
	if (node == NULL) 
		return; 

	/* first recur on left child */
	printInorder(node->left); 

	cout << node->data << " "; 

	/* now recur on right child */
	printInorder(node->right); 
} 

// A utility function to merge
// two sorted arrays into one 
int *merge(int arr1[], int arr2[], int m, int n) 
{ 
	// mergedArr[] is going to contain result 
	int *mergedArr = new int[m + n]; 
	int i = 0, j = 0, k = 0; 

	// Traverse through both arrays 
	while (i < m && j < n) 
	{ 
		// Pick the smaller element and put it in mergedArr 
		if (arr1[i] < arr2[j]) 
		{ 
			mergedArr[k] = arr1[i]; 
			i++; 
		} 
		else
		{ 
			mergedArr[k] = arr2[j]; 
			j++; 
		} 
		k++; 
	} 

	// If there are more elements in first array 
	while (i < m) 
	{ 
		mergedArr[k] = arr1[i]; 
		i++; k++; 
	} 

	// If there are more elements in second array 
	while (j < n) 
	{ 
		mergedArr[k] = arr2[j]; 
		j++; k++; 
	} 

	return mergedArr; 
} 

// A helper function that stores inorder
// traversal of a tree rooted with node 
void storeInorder(node* node, int inorder[], int *index_ptr) 
{ 
	if (node == NULL) 
		return; 

	/* first recur on left child */
	storeInorder(node->left, inorder, index_ptr); 

	inorder[*index_ptr] = node->data; 
	(*index_ptr)++; // increase index for next entry 

	/* now recur on right child */
	storeInorder(node->right, inorder, index_ptr); 
} 

/* A function that constructs Balanced 
// Binary Search Tree from a sorted array 
See https://www.geeksforgeeks.org/sorted-array-to-balanced-bst/ */
node* sortedArrayToBST(int arr[], int start, int end) 
{ 
	/* Base Case */
	if (start > end) 
	return NULL; 

	/* Get the middle element and make it root */
	int mid = (start + end)/2; 
	node *root = newNode(arr[mid]); 

	/* Recursively construct the left subtree and make it 
	left child of root */
	root->left = sortedArrayToBST(arr, start, mid-1); 

	/* Recursively construct the right subtree and make it 
	right child of root */
	root->right = sortedArrayToBST(arr, mid+1, end); 

	return root; 
} 

/* Driver code*/
int main() 
{ 
	/* Create following tree as first balanced BST 
		100 
		/ \ 
		50 300 
	/ \ 
	20 70 
	*/
	node *root1 = newNode(100); 
	root1->left	 = newNode(50); 
	root1->right = newNode(300); 
	root1->left->left = newNode(20); 
	root1->left->right = newNode(70); 

	/* Create following tree as second balanced BST 
			80 
		/ \ 
		40 120 
	*/
	node *root2 = newNode(80); 
	root2->left	 = newNode(40); 
	root2->right = newNode(120); 

	node *mergedTree = mergeTrees(root1, root2, 5, 3); 

	cout << "Following is Inorder traversal of the merged tree \n"; 
	printInorder(mergedTree); 

	return 0; 
} 
