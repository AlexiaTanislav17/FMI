
#include <iostream>
#include <vector>
#include <queue>
#include <climits>
using namespace std;

vector<int> dijkstra(int n, int source, vector<vector<int>> &adjList, vector<vector<int>> &weights) {
    vector<int> dist(n, INT_MAX); // dist min catre fiecare nod
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq; // min-heap

    dist[source] = 0;
    pq.emplace(0, source); // add nod sursa cu dist 0

    while (!pq.empty()) {
        int d = pq.top().first; // dist min curenta
        int u = pq.top().second; // nod curent
        pq.pop();

        if (d > dist[u]) continue; // sarim peste nodurile deja procesate

        // relaxez muchiile
        for (size_t i = 0; i < adjList[u].size(); ++i) {
            int v = adjList[u][i];
            int weight = weights[u][i];
            if (dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                pq.emplace(dist[v], v); // add vecin cu dist updatata
            }
        }
    }

    return dist;
}

int main() {
    int n, m;
    //cout << "n si m: ";
    cin >> n >> m;

    vector<vector<int>> adjList(n);   // lista de adiacenta
    vector<vector<int>> weights(n);   // weight la muchii
    vector<vector<int>> adjList2(n);  //pt copia grafului
    vector<vector<int>> weights2(n);

    //cout << "muchiile (u v):\n";
    for (int i = 0; i < m; ++i) {
        int u, v, w;
        cin >> u >> v;
        w = 1;
        u = u-1;
        v = v-1;
        adjList[u].push_back(v);
        adjList[v].push_back(u);  // daca graful este neorientat, adaugam si muchia inversa
        weights[u].push_back(w);
        weights[v].push_back(w);
        adjList2[u].push_back(v);
        adjList2[v].push_back(u);  // pt copia grafului
        weights2[u].push_back(w);
        weights2[v].push_back(w);
    }

    int source=0;

    vector<int> distances = dijkstra(n, source, adjList, weights);


//    cout << "cea mai mica distanta este " << source << ":\n";
//    cout << "de la 1 la " << n << ": "<< distances[n-1] << endl;

    int q;
    //cout << "muchii de adaugat: ";
    cin >> q;
    m = m + q;

    vector<int> oracol(q);

    for (int i = 0; i < q; ++i) {

        vector<vector<int>> adjList3(n);
        vector<vector<int>> weights3(n);

//        for(int k = 0; k<n; k++){
//            for(size_t j = 0; j < adjList[k].size(); j++){
//                adjList3[k][j] = adjList[k][j];
//                weights3[k][j] = weights[k][j];
//            }
//        }

        int u, v, w;
        cin >> u >> v;
        w = 1;
        u = u-1;
        v = v-1;
        adjList2[u].push_back(v);
        adjList2[v].push_back(u);  // daca graful este neorientat, adaugam si muchia inversa
        weights2[u].push_back(w);
        weights2[v].push_back(w);

        vector<int> distances2 = dijkstra(n, source, adjList2, weights2);

        if (distances2[n-1] < distances[n-1]) {
            //cout << "1";
            oracol[i]=1;
        }else{
            //cout << "0";
            oracol[i]=0;
        }


    }

    //cout << endl;

    for (int i = 0; i < q; ++i) {
        cout << oracol[i];
    }

    // am folosit dijkstra ca sa gasesc cel mai mic drum de la nodul 1 la n si dupa am adaugat pe rand muchiile ca sa verific daca face drumul mai scurt

    return 0;
}
