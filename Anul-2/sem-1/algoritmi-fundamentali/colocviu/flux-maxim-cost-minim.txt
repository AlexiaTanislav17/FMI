#include <iostream>
#include <vector>
#include <climits>
#include <queue>
#include <cstring>
using namespace std;

const int INF = INT_MAX;

// BFS pentru a găsi un drum de augmentare în fluxul rezidual
bool bfs(int n, vector<vector<int>> &capacity, vector<vector<int>> &adj, vector<int> &parent, vector<vector<int>> &cost, int source, int sink) {
    vector<int> dist(n, INF);
    dist[source] = 0;
    parent[source] = -1;

    queue<int> q;
    q.push(source);

    while (!q.empty()) {
        int u = q.front();
        q.pop();

        for (int v : adj[u]) {
            if (capacity[u][v] > 0 && dist[v] > dist[u] + cost[u][v]) {
                dist[v] = dist[u] + cost[u][v];
                parent[v] = u;
                q.push(v);
            }
        }
    }

    return dist[sink] != INF;
}

// Algoritmul Fluxului Maxim de Cost Minim
int minCostMaxFlow(int n, vector<vector<int>> &capacity, vector<vector<int>> &adj, vector<vector<int>> &cost, int source, int sink) {
    vector<int> parent(n);
    int maxFlow = 0, minCost = 0;

    while (bfs(n, capacity, adj, parent, cost, source, sink)) {
        int pathFlow = INF;
        for (int v = sink; v != source; v = parent[v]) {
            int u = parent[v];
            pathFlow = min(pathFlow, capacity[u][v]);
        }

        // Actualizăm fluxul și capacitățile
        for (int v = sink; v != source; v = parent[v]) {
            int u = parent[v];
            capacity[u][v] -= pathFlow;
            capacity[v][u] += pathFlow;
            minCost += pathFlow * cost[u][v];
        }

        maxFlow += pathFlow;
    }

    return minCost;
}

int main() {
    int n = 4; // Numărul de noduri
    int source = 0, sink = 3;

    // Capacitățile dintre noduri
    vector<vector<int>> capacity(n, vector<int>(n, 0));
    vector<vector<int>> cost(n, vector<int>(n, 0)); // Costurile asociate

    // Lista de adiacență
    vector<vector<int>> adj(n);

    // Adăugăm muchii cu capacități și costuri
    auto addEdge = [&](int u, int v, int cap, int c) {
        capacity[u][v] = cap;
        cost[u][v] = c;
        adj[u].push_back(v);
        adj[v].push_back(u);
    };

    addEdge(0, 1, 3, 1); // Capacitate 3, cost 1
    addEdge(0, 2, 2, 1); // Capacitate 2, cost 1
    addEdge(1, 2, 2, 2); // Capacitate 2, cost 2
    addEdge(1, 3, 3, 3); // Capacitate 3, cost 3
    addEdge(2, 3, 3, 1); // Capacitate 3, cost 1

    cout << "Minimum Cost of Maximum Flow: " << minCostMaxFlow(n, capacity, adj, cost, source, sink) << endl;

    return 0;
}
