#include <bits/stdc++.h>
using namespace std;

vector<int> parent;

// Initialize the disjoint-set data structure
void disjoint(int size)
{
    parent.resize(size + 1);
    for (int i = 0; i <= size; i++)
      
        // Each element is initially its own parent
        parent[i] = i;
}

// Finding the representative of the
// disjoint-set containing 'u'
int find(int u)
{
    // If 'u' is its own parent, it's the
    // representative.
    if (parent[u] == u)
        return u;
  
    // Path compression.
    return parent[u] = find(parent[u]);
}

// Merge two disjoint-sets
// represented by 'u' and 'v'
void merge(int u, int v)
{
    int ua = find(u);
    int ub = find(v);
    // Set the representative of 'u' as the
    // representative of 'v'.
    parent[ua] = ub;
}

// function to find the minimum
// spanning tree (MST) weight
int help1(vector<vector<int> >& e, int j, int n)
{
    disjoint(n + 1);
    vector<pair<int, pair<int, int> > > v;
  
    for (int i = 0; i < e.size(); i++) {
        if (i == j)
            continue;
      
        // Add edge weight and
        // vertices to 'v'.
        v.push_back({ e[i][2], { e[i][0], e[i][1] } });
    }
  
    // Sort edges by weight.
    sort(v.begin(), v.end());
  
    int mst_weight = 0;
    int edges = 0;
  
    for (int i = 0; i < v.size(); i++) {
      
        auto x = v[i];
        int u = find(x.second.first);
        int v = find(x.second.second);
      
        if (u != v) {
          
            // Add edge weight to MST.
            edges++;
            mst_weight += x.first;
          
            // Merge the disjoint-sets
            // of 'u' and 'v'.
            merge(u, v);
        }
    }
  
    // If not all vertices
    // are included in MST.
    if (edges != n - 1)
        return INT_MAX;
  
    return mst_weight;
}

// function to find MST weight after
// including one additional edge
int help2(vector<vector<int> >& e, int j, int n)
{
    disjoint(n + 1);
  
    // Include the current edge in MST.
    int mst_weight = e[j][2];
  
    // Merge vertices of the current edge.
    merge(e[j][1], e[j][0]);
  
    vector<pair<int, pair<int, int> > > v;
    for (int i = 0; i < e.size(); i++) {
      
        if (i == j)
            continue;
      
        // Add edge weight and
        // vertices to 'v'.
        v.push_back({ e[i][2], { e[i][0], e[i][1] } });
    }
  
    // Sort edges by weight.
    sort(v.begin(), v.end());
  
    for (int i = 0; i < v.size(); i++) {
      
        auto x = v[i];
        int u = find(x.second.first);
        int v = find(x.second.second);
      
        if (u != v) {
          
            // Add edge weight to MST.
            mst_weight += x.first;
          
            // Merge the disjoint-sets of 'u'
            // and 'v'.
            merge(u, v);
        }
    }
    return mst_weight;
}

// Function to determine whether the edge
// is Critical or Pseudi-Critical
vector<vector<int> >
findCriticalAndPseudoCriticalEdges(int n,
                                   vector<vector<int> >& e)
{
    disjoint(n + 1);
  
    // Compute MST weight without any excluded edge.
    int mst_weight = help1(e, -1, n);
  
  
    // Store critical edges in v1 and
    // pseudo-critical edges in v2.
    vector<int> v1, v2;

    // combine v1 and v2 to return
    // as a 2d vector
    vector<vector<int> > ans;
  
    for (int i = 0; i < e.size(); i++) {
      
        // MST weight without the i-th edge.
        int new_weight1 = help1(e, i, n);
      
        // MST weight with the i-th edge.
        int new_weight2 = help2(e, i, n);
      
        // i-th edge is critical.
        if (new_weight1 > mst_weight) {
            v1.push_back(i);
        }
      
        // i-th edge is pseudo-critical.
        else if (new_weight2 == mst_weight) {
            v2.push_back(i);
        }
    }
  
    // Critical edges.
    ans.push_back(v1);
  
    // Pseudo-critical edges.
    ans.push_back(v2);
    return ans;
}

// Driver code
int main()
{
    int vertices = 5;
    vector<vector<int> > ans;
    vector<vector<int> > edges;
    edges.push_back({ 0, 1, 1 });
    edges.push_back({ 1, 2, 1 });
    edges.push_back({ 2, 3, 2 });
    edges.push_back({ 0, 3, 2 });
    edges.push_back({ 0, 4, 3 });
    edges.push_back({ 3, 4, 3 });
    edges.push_back({ 1, 4, 6 });
    ans = findCriticalAndPseudoCriticalEdges(vertices,
                                             edges);

    // Printing the ans
    for (auto it : ans) {
        cout << "[";
        for (auto i : it) {
            cout << i << " ";
        }
        cout << "]";
        cout << endl;
    }
    return 0;
}